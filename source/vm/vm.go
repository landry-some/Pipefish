package vm

import (
	"pipefish/source/object"
	"pipefish/source/text"
	"pipefish/source/token"
	"pipefish/source/values"

	"strconv"
	"strings"
)

type Vm struct {
	// Temporary state: things we change at runtime.
	mem       []values.Value
	callstack []uint32
	code      []*operation

	// Permanent state: things established at compile time.

	ub_enums        uint32
	typeNames       []string
	enums           [][]string
	tokens          []*token.Token
	lambdaFactories []*lambdaFactory
}

// All the information we need to make a lambda at a particular point in the code.
type lambdaFactory struct {
	model  *lambda  // Copy this to make the lambda.
	extMem []uint32 // Then these are the location of the values we're closing over, so we copy them into the lambda.
	size   uint32   // The size of te memory for a new VM.
}

type lambda struct {
	vm        *Vm
	extTop    uint32
	prmTop    uint32
	dest      uint32
	locToCall uint32
	captures  []values.Value
}

func (vm *Vm) memTop() uint32 {
	return uint32(len(vm.mem))
}

func (vm *Vm) that() uint32 {
	return uint32(len(vm.mem) - 1)
}

func (vm *Vm) thatToken() uint32 {
	return uint32(len(vm.tokens) - 1)
}

func (vm *Vm) codeTop() uint32 {
	return uint32(len(vm.code))
}

func (vm *Vm) tokenTop() uint32 {
	return uint32(len(vm.tokens))
}

func (vm *Vm) lfTop() uint32 {
	return uint32(len(vm.lambdaFactories))
}

func (vm *Vm) next() uint32 {
	return uint32(len(vm.code))
}

// This adds together two vms. They are presumed to share everything but the code field, the second having been
// generated by the .tempVm method, and so all that is necessary is to add the code, tokens, and lfcs of one to the other while
// changing all the locations to match.
func (vm *Vm) add(vmToAdd *Vm) {
	start := vm.codeTop()
	tokStart := vm.tokenTop()
	lfStart := vm.lfTop()
	for _, v := range vmToAdd.code {
		if len(v.args) > 1 && OPERANDS[v.opcode].or[len(v.args)-1] == loc {
			v.args[len(v.args)-1] += start
		}
		if len(v.args) > 1 && OPERANDS[v.opcode].or[len(v.args)-1] == tok {
			v.args[len(v.args)-1] += tokStart
		}
		if len(v.args) > 1 && OPERANDS[v.opcode].or[len(v.args)-1] == lfc {
			v.args[len(v.args)-1] += lfStart
		}
		vm.code = append(vm.code, v)
	}
	vm.tokens = append(vm.tokens, vmToAdd.tokens...)
	vm.lambdaFactories = append(vm.lambdaFactories, vmToAdd.lambdaFactories...)
}

var OPCODE_LIST []func(vm *Vm, args []uint32)

var CONSTANTS = []values.Value{values.FALSE, values.TRUE, values.U_OBJ}

func blankVm() *Vm {
	newVm := &Vm{mem: CONSTANTS}
	// Cross-reference with consts in values.go. TODO --- find something less stupidly brittle to do instead.
	newVm.typeNames = []string{"UNDEFINED VALUE!!! values.ERROR!", "thunk", "created local constant", "tuple", "error", "unsat", "ref", "null",
		"int", "bool", "string", "float64", "type", "func", "list"}
	return newVm
}

func (vm *Vm) Run(loc uint32) {
	if SHOW_RUN {
		print("\nRunning:\n\n")
	}
loop:
	for {
		if SHOW_RUN {
			println(text.RED + vm.describeCode(loc) + text.RESET)
		}
		args := vm.code[loc].args
		switch vm.code[loc].opcode {
		case Addf:
			vm.mem[args[0]] = values.Value{values.FLOAT, vm.mem[args[1]].V.(float64) + vm.mem[args[2]].V.(float64)}
		case Addi:
			vm.mem[args[0]] = values.Value{values.INT, vm.mem[args[1]].V.(int) + vm.mem[args[2]].V.(int)}
		case Adds:
			vm.mem[args[0]] = values.Value{values.STRING, vm.mem[args[1]].V.(string) + vm.mem[args[2]].V.(string)}
		case Adtk:
			(vm.mem[args[0]].V.(*object.Error)).AddToTrace(vm.tokens[args[1]])
		case Andb:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(bool) && vm.mem[args[2]].V.(bool)}
		case Asgm:
			vm.mem[args[0]] = vm.mem[args[1]]
		case Call:
			offset := args[1]
			for i := args[1]; i < args[2]; i++ {
				vm.mem[i] = vm.mem[args[3+i-offset]]
			}
			vm.callstack = append(vm.callstack, loc)
			loc = args[0]
			continue
		case Cc11:
			vm.mem[args[0]] = values.Value{values.TUPLE, []values.Value{vm.mem[args[1]], vm.mem[args[2]]}}
		case Cc1T:
			vm.mem[args[0]] = values.Value{values.TUPLE, append([]values.Value{vm.mem[args[1]]}, vm.mem[args[2]].V.([]values.Value)...)}
		case CcT1:
			vm.mem[args[0]] = values.Value{values.TUPLE, append(vm.mem[args[1]].V.([]values.Value), vm.mem[args[2]])}
		case CcTT:
			vm.mem[args[0]] = values.Value{values.TUPLE, append(vm.mem[args[1]].V.([]values.Value), vm.mem[args[2]])}
		case Ccxx:
			if vm.mem[args[1]].T == values.TUPLE {
				if vm.mem[args[2]].T == values.TUPLE {
					vm.mem[args[0]] = values.Value{values.TUPLE, append(vm.mem[args[1]].V.([]values.Value), vm.mem[args[2]])}
				} else {
					vm.mem[args[0]] = values.Value{values.TUPLE, append(vm.mem[args[1]].V.([]values.Value), vm.mem[args[2]])}
				}
			} else {
				if vm.mem[args[2]].T == values.TUPLE {
					vm.mem[args[0]] = values.Value{values.TUPLE, append([]values.Value{vm.mem[args[1]]}, vm.mem[args[2]].V.([]values.Value)...)}
				} else {
					vm.mem[args[0]] = values.Value{values.TUPLE, []values.Value{vm.mem[args[1]], vm.mem[args[2]]}}
				}
			}
		case Cv1T:
			vm.mem[args[0]] = values.Value{values.TUPLE, []values.Value{vm.mem[args[1]]}}
		case Divf:
			vm.mem[args[0]] = values.Value{values.FLOAT, vm.mem[args[1]].V.(float64) / vm.mem[args[2]].V.(float64)}
		case Divi:
			vm.mem[args[0]] = values.Value{values.INT, vm.mem[args[1]].V.(int) / vm.mem[args[2]].V.(int)}
		case Dofn:
			lhs := vm.mem[args[1]].V.(lambda)
			for i := 0; i < int(lhs.prmTop-lhs.extTop); i++ {
				lhs.vm.mem[int(lhs.extTop)+i] = vm.mem[args[2+i]]
			}
			copy(lhs.captures, vm.mem)
			lhs.vm.Run(lhs.locToCall)
			vm.mem[args[0]] = lhs.vm.mem[lhs.dest]
		case Dref:
			vm.mem[args[0]] = vm.mem[vm.mem[args[1]].V.(uint32)]
		case Equb:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(bool) == vm.mem[args[2]].V.(bool)}
		case Equf:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(float64) == vm.mem[args[2]].V.(float64)}
		case Equi:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(int) == vm.mem[args[2]].V.(int)}
		case Equs:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(string) == vm.mem[args[2]].V.(string)}
		case Flti:
			vm.mem[args[0]] = values.Value{values.FLOAT, float64(vm.mem[args[1]].V.(int))}
		case Flts:
			i, err := strconv.ParseFloat(vm.mem[args[1]].V.(string), 64)
			if err != nil {
				vm.mem[args[0]] = values.Value{values.ERROR, DUMMY}
			} else {
				vm.mem[args[0]] = values.Value{values.FLOAT, i}
			}
		case Gtef:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(float64) >= vm.mem[args[2]].V.(float64)}
		case Gtei:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(int) >= vm.mem[args[2]].V.(int)}
		case Gthf:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(float64) > vm.mem[args[2]].V.(float64)}
		case Gthi:
			vm.mem[args[0]] = values.Value{values.BOOL, vm.mem[args[1]].V.(int) > vm.mem[args[2]].V.(int)}
		case Halt:
			break loop
		case Intf:
			vm.mem[args[0]] = values.Value{values.INT, int(vm.mem[args[1]].V.(float64))}
		case Ints:
			i, err := strconv.Atoi(vm.mem[args[1]].V.(string))
			if err != nil {
				vm.mem[args[0]] = values.Value{values.ERROR, DUMMY}
			} else {
				vm.mem[args[0]] = values.Value{values.INT, i}
			}
		case IdxT:
			vm.mem[args[0]] = vm.mem[args[1]].V.([]values.Value)[args[2]]
		case Jmp:
			loc = args[0]
			continue
		case Jsr:
			vm.callstack = append(vm.callstack, loc)
			loc = args[0]
			continue
		case Lens:
			vm.mem[args[0]] = values.Value{values.INT, len(vm.mem[args[1]].V.(string))}
		case Litx:
			vm.mem[args[0]] = values.Value{values.STRING, vm.literal(vm.mem[args[1]])}
		case Mker:
			vm.mem[args[0]] = values.Value{values.ERROR, &object.Error{ErrorId: "eval/user", Message: vm.mem[args[1]].V.(string), Token: vm.tokens[args[2]]}}
		case Mkfn:
			lf := vm.lambdaFactories[args[1]]
			newLambda := *lf.model
			newLambda.captures = make([]values.Value, len(lf.extMem))
			for i, v := range lf.extMem {
				newLambda.captures[i] = vm.mem[v]
			}
			vm.mem[args[0]] = values.Value{values.FUNC, newLambda}
		case Modi:
			vm.mem[args[0]] = values.Value{values.INT, vm.mem[args[1]].V.(int) % vm.mem[args[2]].V.(int)}
		case Mulf:
			vm.mem[args[0]] = values.Value{values.FLOAT, vm.mem[args[1]].V.(float64) * vm.mem[args[2]].V.(float64)}
		case Muli:
			vm.mem[args[0]] = values.Value{values.INT, vm.mem[args[1]].V.(int) * vm.mem[args[2]].V.(int)}
		case Negf:
			vm.mem[args[0]] = values.Value{values.FLOAT, -vm.mem[args[1]].V.(float64)}
		case Negi:
			vm.mem[args[0]] = values.Value{values.INT, -vm.mem[args[1]].V.(int)}
		case Notb:
			vm.mem[args[0]] = values.Value{values.BOOL, !vm.mem[args[1]].V.(bool)}
		case Orb:
			vm.mem[args[0]] = values.Value{values.BOOL, (vm.mem[args[1]].V.(bool) || vm.mem[args[2]].V.(bool))}
		case QlnT:
			if len(vm.mem[args[0]].V.([]values.Value)) == int(args[1]) {
				loc = loc + 1
			} else {
				loc = args[2]
			}
		case Qsng:
			if vm.mem[args[0]].T >= values.INT {
				loc = loc + 1
			} else {
				loc = args[1]
			}
			continue
		case QsnQ:
			if vm.mem[args[0]].T >= values.NULL {
				loc = loc + 1
			} else {
				loc = args[1]
			}
			continue
		case Qtru:
			if vm.mem[args[0]].V.(bool) {
				loc = loc + 1
			} else {
				loc = args[1]
			}
			continue
		case Qtyp:
			if vm.mem[args[0]].T == values.ValueType(args[1]) {
				loc = loc + 1
			} else {
				loc = args[2]
			}
			continue
		case Ret:
			if len(vm.callstack) == 0 {
				break loop
			}
			loc = vm.callstack[len(vm.callstack)-1]
			vm.callstack = vm.callstack[0 : len(vm.callstack)-1]
		case Strx:
			vm.mem[args[0]] = values.Value{values.STRING, vm.describe(vm.mem[args[1]])}
		case Subf:
			vm.mem[args[0]] = values.Value{values.FLOAT, vm.mem[args[1]].V.(float64) - vm.mem[args[2]].V.(float64)}
		case Subi:
			vm.mem[args[0]] = values.Value{values.INT, vm.mem[args[1]].V.(int) - vm.mem[args[2]].V.(int)}
		case Thnk:
			vm.mem[args[0]].T = values.THUNK
			vm.mem[args[0]].V = args[1]
		case Typx:
			vm.mem[args[0]] = values.Value{values.TYPE, vm.mem[args[1]].T}
		case Untk:
			if (vm.mem[args[0]].T) == values.THUNK {
				vm.callstack = append(vm.callstack, loc)
				loc = vm.mem[args[0]].V.(uint32)
				continue
			}
		default:
			panic("Unhandled opcode!")
		}
		loc++
	}
	if SHOW_RUN {
		println()
	}
}

func (vm *Vm) describeCode(loc uint32) string {
	prefix := "@" + strconv.Itoa(int(loc)) + " : "
	spaces := strings.Repeat(" ", 6-len(prefix))
	return spaces + prefix + describe(vm.code[loc])
}

func (vm *Vm) describeType(t typeScheme) string {
	if t == nil {
		return "nil"
	}
	switch t := t.(type) {
	case simpleType:
		return vm.typeNames[t]
	case alternateType:
		if len(t) == 0 {
			return "∅"
		}
		tList := []string{}
		for _, v := range t {
			tList = append(tList, vm.describeType(v))
		}
		return "[" + strings.Join(tList, "/") + "]"
	case finiteTupleType:
		tList := []string{}
		for _, v := range t {
			tList = append(tList, vm.describeType(v))
		}
		return "tuple with (" + strings.Join(tList, ", ") + ")"
	case typedTupleType:
		return "tuple of (" + vm.describeType(t.t) + ")"
	case blingType:
		return t.tag
	}
	panic("unimplemented type")
}

func (vm *Vm) describe(v values.Value) string {
	switch v.T {
	case values.INT:
		return strconv.Itoa(v.V.(int))
	case values.LIST:
		result := make([]string, len(v.V.([]values.Value)))
		for i, v := range v.V.([]values.Value) {
			result[i] = vm.describe(v)
		}
		return "[" + strings.Join(result, ", ") + ")"
	case values.STRING:
		return v.V.(string)
	case values.TYPE:
		return vm.describeType(v.V.(simpleType))
	case values.BOOL:
		if v.V.(bool) {
			return "true"
		} else {
			return "false"
		}
	case values.FLOAT:
		return strconv.FormatFloat(v.V.(float64), 'f', 8, 64)
	case values.UNSAT:
		return "unsatisfied conditional"
	case values.NULL:
		return "values.NULL"
	case values.THUNK:
		return "thunk"
	case values.TUPLE:
		result := make([]string, len(v.V.([]values.Value)))
		for i, v := range v.V.([]values.Value) {
			result[i] = vm.describe(v)
		}
		prefix := "("
		if len(result) == 1 {
			prefix = "tuple("
		}
		return prefix + strings.Join(result, ", ") + ")"
	case values.ERROR:
		ob := v.V.(*object.Error)
		if ob.ErrorId != "eval/user" {
			ob = object.CreateErr(ob.ErrorId, ob.Token, ob.Args...)
		}
		return text.Pretty(text.RT_ERROR+ob.Message+text.DescribePos(ob.Token)+".", 0, 80)
	case values.FUNC:
		return "lambda function"
	case values.UNDEFINED_VALUE:
		return "UNDEFINED VALUE! values.ERROR!"
	}

	panic("can't describe value")
}

func (vm *Vm) literal(v values.Value) string {
	switch v.T {
	case values.STRING:
		return "\"" + v.V.(string) + "\""
	default:
		return vm.describe(v)
	}
}
