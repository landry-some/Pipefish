// This file provides the type signatures for the builtin functions.

def

// Symbols are in alphabetical order of their hooks.

(x float64) + (y float64) : builtin "add_floats"
(x int) + (y int) : builtin "add_integers"
(x list) + (y list) : builtin "add_lists"
(x set) + (y set) : builtin "add_sets"
(x string) + (y string) : builtin "add_strings"
(x float64) / (y float64) : builtin "divide_floats"
(x int) / (y int) : builtin "divide_integers"
(x float64) > (y float64) : builtin "gt_floats"
(x float64) >= (y float64) : builtin "gte_floats"
(x int) > (y int) : builtin "gt_ints"
(x int) >= (y int) : builtin "gte_ints"
(x float64) < (y float64) : builtin "lt_floats"
(x float64) <= (y float64) : builtin "lte_floats"
(x int) < (y int) : builtin "lt_ints"
(x int) <= (y int) : builtin "lte_ints"
(x single?) :: (y single?) : builtin "make_pair"
(x int) % (y int) : builtin "modulo_integers"
(x float64) * (y float64) : builtin "multiply_floats"
(x int) * (y int) : builtin "multiply_integers"
- (x float64) : builtin "negate_float"
- (x int) : builtin "negate_integer"
(x float64) - (y float64) : builtin "subtract_floats"
(x int) - (y int) : builtin "subtract_integers"

// Ordinary functions are in order of their function name.

aritymaker(x tuple) : builtin "len_tuple"    // Kludge to deal with the fact that builtins don't know how to capture tuples.
arity(x tuple) : aritymaker x   
error(x string) : builtin "make_error"
float(x int) : builtin "float_of_int"
float(x string) : builtin "float_of_string"
(x single?) in (y list) : builtin "single_in_list"
(x single?) in (y set) : builtin "single_in_set"
intuplemaker(x single?, y tuple) : builtin "single_in_tuple"
(x single?) in (y tuple) : intuplemaker x, y
(x single?) in (y type) : builtin "single_in_type"
int(x string) : builtin "int_of_string"
int(x float64) : builtin "int_of_float"
keys(x map) : builtin "keys_of_map"
keys(x struct) : builtin "keys_of_struct"
len(x list) : builtin "len_list"
len(x map) : builtin "len_map"
len(x set) : builtin "len_set"
len(x string) : builtin "len_string"
mapmaker(x tuple) : builtin "make_map"    // Kludge to deal with the fact that builtins don't know how to capture tuples.
map(x tuple) : mapmaker x                 //
setmaker(x tuple) : builtin "make_set"    // TODO --- something better.
set(x tuple) : setmaker x                 // 
string(x single?) : builtin "string"
tuple(x tuple) : builtin "tuple_of_tuple"
tuplify(L list) : builtin "tuplify_list"
type(x single?) : builtin "type"
type(x tuple) : builtin "type_of_tuple"
listwithmaker(x list, y tuple)  : builtin "list_with"
(x list) with (y tuple) : listwithmaker x, y   
mapwithmaker(x map, y tuple)  : builtin "map_with"
(x map) with (y tuple) : mapwithmaker x, y   
structwithmaker(x struct, y tuple)  : builtin "struct_with"
(x struct) with (y tuple) : structwithmaker x, y   
typewithmaker(x type, y tuple) : builtin "type_with" 
(x type) with (y tuple) : typewithmaker x, y        
mapwithoutmaker(x map, y tuple)  : builtin "map_without"
(x map) without (y tuple) : mapwithoutmaker x, y    

Color = enum RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE

Number = enum ONE, TWO, THREE

Person = struct(name string, age int)

foo(str struct, lab label) :
    str[lab]

X = [1, 2]

Y = set 1, 2

(i int) goo (t tuple) :
    t

(x int) fnarf (y int) : x * y

doug = Person("Douglas", 42)

myList = [[1, 2], [3, 4]]

myMap = map 1::BLUE, 2::GREEN, 3::RED

troz(Z struct) :
    Z[age]

id(x) :
    x

private

zort(x) :
    x

var

myVar = 42
myOtherVar = 42

cmd

spoit(x int) :
    global myVar, myOtherVar
    y = x
    myVar = x
    myOtherVar = 2 * y

cmd

(x ref) ++ :
    x = x + 1

def

pruit() :
    2 + 2 == 3 or 2 + 2 == 4 :
        "foo"
    else :
        "bar"
