import

gocode "io/ioutil"
gocode "bufio"
gocode "math/rand"
gocode "os"
gocode "time"
gocode "errors"

types

Clock = struct()
File = struct(filepath string, asType type)
FileExists = struct(filepath string)
Input = struct(prompt string)
Output = struct()
Random = struct(params single)
RandomSeed = struct()
Terminal = struct()

def

//File(filepath string) :
//    File(filepath, string) 


cmd

posttooutputmaker(x single) : builtin "post_to_output"
post (x single) to (o Output): posttooutputmaker(x)
post (x single) : builtin "post_to_output"
// post (x tuple) to (o Output): posttooutputmaker(x)

posttoterminalmaker(x single) : builtin "post_to_terminal"
post (x single) to (t Terminal): posttoterminalmaker(x)

get (x ref) from (i Input) : builtin "get_from_input"

def

goGetClock() -> Time : gocode {
    goNow := time.Now()
    return Time{goNow.Year(), int(goNow.Month()), goNow.Day(), goNow.Hour(), goNow.Minute(), goNow.Second(), goNow.Nanosecond(), goNow.Location().String()}
}

goFileExists(fname string) : gocode {
     _, err := os.Stat(fname)
     return err == nil
}

cmd

goRandomize(i int) : gocode {
    rand.Seed(int64(i))
    return values.Value{values.SUCCESSFUL_VALUE, nil}
}

put (seed int) into (randomizer RandomSeed) :
    goRandomize(seed)

get (x ref) from (c Clock) :
    x = goGetClock() 

def

goRandomInt(i int) : gocode {
    return rand.Intn(i)
}

randomFunctionOf(random Random) :
    type r == int : 
        r <= 0 :
            error "range of Random object cannot be <= 0"
        else :
            goRandomInt(r)
    type r == list :
        r == [] :
            error "can't take random element of empty list"
        else :
            r[goRandomInt(len r)]
    else :
        error "can't randomize things of type " + string(type r)
given :
    r = random[params]

cmd

get (x ref) from (random Random) :
     x = randomFunctionOf(random)  


def

goGetFileAsString(fname string) : gocode {
    fileContent, err := ioutil.ReadFile(fname)
    if err != nil {
        return errors.New("can't find file '" + fname + "'")
    }
    return string(fileContent)
}

goGetFileAsList(fname string) : gocode {
    file, err := os.Open(fname)
	if err != nil {
		return errors.New("can't find file '" + fname + "'")
	}
	defer file.Close()

	result := []string{}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		result = append(result, scanner.Text())
	}
	return result
}

cmd

get (contents ref) from (fileAccess File) : 
    fileAccess[asType] == string :
        contents = goGetFileAsString(fileAccess[filepath])
    fileAccess[asType] == list :
        contents = goGetFileAsList(fileAccess[filepath])
    else :
        error "can't get file as type '" + string(fileAccess[asType]) + "'"

get (x ref) from (fileAccess FileExists) :
    x = goFileExists(fileAccess[filepath])
